#!/bin/bash

valid_bash_var_name() {
    local input_string="$1"

    # Replace invalid characters with underscores
    # and ensure the string starts with a letter or underscore.
    # sed 's/[^a-zA-Z0-9_]/_/g' <<< "$var_name"
    local sanitized_string=$(echo "$input_string" | sed 's/[^a-zA-Z0-9_]/_/g')

    echo "$sanitized_string"
}

ensure_env_file_exists() {
    env_file=${1:-$ENV_FILE}

    if [ -z "$env_file" ]; then
        log_error "Environment file path is not set."
        return 1
    fi

    if [ ! -f "$env_file" ]; then
        sudo touch "$env_file"
    fi

    # Ensure the owner of the .env file is $XB_USER
    if [ "$(stat -f %Su "$env_file")" != "$XB_USER" ]; then
        sudo chown "$XB_USER:$XB_USERGROUP" "$env_file"
    fi

    # Ensure the .env file is only writable by the owner but readable by everyone
    if [ "$(stat -f %A "$env_file")" != "640" ]; then
        sudo chmod 640 "$env_file"
    fi

    if [ -f "$env_file" ]; then
        if [ ! -r "$env_file" ]; then
            log_error "Environment file is not readable."
            return 1
        fi
        if [ ! -w "$env_file" ]; then
            log_error "Environment file is not writable."
            return 1
        fi

        local env_file_empty="false"
        #check if contents of the file are exactly the same as the template
        if [ -s "$env_file" ]; then
            local template_contents=$(cat "$XB_HOME/xbash_profile-template")
            local env_file_contents=$(cat "$env_file")
            if [ "$template_contents" == "$env_file_contents" ]; then
                env_file_empty="true"
            fi
        fi

        if [ ! -s "$env_file" ] || [ "$env_file_empty" == "true" ]; then
            log_state "Environment file is empty. Writing initial values."
            set_env_var "XB_HOME" "$XB_HOME"
            set_env_var "INFRA_DIR" "$INFRA_DIR"
            set_env_var "INFRA_DIR" "$INFRA_DIR"
            set_env_var "ABRCITY_HOME" "$ABRCITY_HOME"
            set_env_var "MACHINEFABRIC_HOME" "$MACHINEFABRIC_HOME"
            set_env_var "MG_WORKDIR" "$MG_WORKDIR"
            set_env_var "XB_USER" "$XB_USER"
            set_env_var "XB_USERGROUP" "$XB_USERGROUP"
            set_env_var "XB_USER_HOME" "$XB_USER_HOME"
            set_env_var "LOG_LEVEL" "$LOG_LEVEL"
            set_env_var "HOST_LAN_ADAPTER" "$HOST_LAN_ADAPTER"
            set_env_var "HOST_WLAN_ADAPTER" "$HOST_WLAN_ADAPTER"
        fi
    fi
}

escape_value() {
    local value="$1"
    echo "$value" | sed -e "s/'/'\\\\''/g; 1s/^/'/; \$s/\$/'/"
}

update_env_file() {
    local var_name="$1"
    local value="$2"
    local env_file=${3:-$ENV_FILE}
    local valid_var_name=$(valid_bash_var_name "$var_name")
    local escaped_value=$(escape_value "$value")

    if [ -z "$env_file" ]; then
        log_error "Environment file path is not set." 2>/dev/null
        return 1
    fi

    if [ ! -f "$env_file" ]; then
        log_error "Environment file does not exist."
        return 1
    elif [ ! -w "$env_file" ]; then
        log_error "Environment file is not writable."
        return 1
    fi

    # Check if the variable already exists and replace or append accordingly
    if grep -q "^export $valid_var_name=" "$env_file"; then
        # Variable exists, replace its value
        sed -i '' "s|^export $valid_var_name=.*|export $valid_var_name=$escaped_value|" "$env_file"
    else
        # Variable does not exist, append to file
        echo "export $valid_var_name=$escaped_value" >>"$env_file"
    fi
}

load_env_file_if_not_set() {
    env_file=${1:-$ENV_FILE}
    if [ -z "$env_file" ]; then
        log_fatal "Environment file path is not set."
        return 1
    fi

    if [ -f "$env_file" ]; then
        if [ ! -r "$env_file" ]; then
            log_fatal "Environment file is not readable."
            return 1
        fi
    else
        log_fatal "Environment file does not exist."
        return 1
    fi

    # Read each line from the env file
    while IFS='=' read -r key value; do
        # Remove 'export ' from the start of the key if present
        key=$(echo "$key" | sed 's/^export //')

        # Trim leading and trailing whitespace from key
        key=$(echo "$key" | xargs)

        # Check if variable is unset in the current environment
        if [ -z "${!key}" ]; then
            # Evaluate the line directly to export it
            eval "$key=$value"
            log_debug "Set $key to $value"
        else
            log_debug "$key is already set to ${!key}"
        fi
    done <"$env_file"
}

set_env_var() {
    local var_name="$1"
    local value="$2"
    local env_file=${3:-$ENV_FILE}

    # Check if variable name and value were provided
    if [[ -z "$var_name" || -z "$value" ]]; then
        log_fatal "Usage: set_env_var <variable_name> <value>: $var_name $value"
        return 1
    fi

    # Check if the value contains newlines
    if [[ "$value" == *$'\n'* ]]; then
        # Value contains newlines; wrap it in quotes
        value="\"$value\""
    elif [[ "$value" == *\ * ]]; then
        # Value contains spaces; wrap it in quotes
        value="\"$value\""
    fi

    # Export the environment variable
    export "$var_name=$value"
    log_debug "Set $var_name=$value" 2>/dev/null
    update_env_file "$var_name" "$value" "$env_file"
}

get_env_var() {
    local var_name="$1"
    local env_file=${2:-$ENV_FILE}

    # Check if variable name was provided
    if [ -z "$var_name" ]; then
        log_fatal "Usage: get_env_var <variable_name>"
        return 1
    fi

    # Check if the variable is set in the current environment
    if [ -z "${!var_name}" ]; then
        # Variable is not set in the current environment
        log_debug "$var_name is not set in the current environment."
        # Check if the variable is set in the environment file
        if grep -q "^export $var_name=" "$env_file"; then
            # Variable is set in the environment file
            local value=$(grep "^export $var_name=" "$env_file" | cut -d'=' -f2-)
            # Remove leading and trailing whitespace
            value=$(echo "$value" | xargs)
            log_debug "$var_name is set to $value in the environment file."
            # Export the variable to the current environment
            export "$var_name=$value"
            # Return the value
            echo "$value"
        else
            # Variable is not set in the environment file
            log_debug "$var_name is not set in the environment file."
            return 1
        fi
    else
        # Variable is set in the current environment
        log_debug "$var_name is set to ${!var_name} in the current environment."
        # Return the value
        echo "${!var_name}"
    fi
}

unset_env_var() {
    local var_name="$1"
    local env_file=${2:-$ENV_FILE}

    # Check if variable name was provided
    if [ -z "$var_name" ]; then
        log_fatal "Usage: unset_env_var <variable_name>"
        return 1
    fi

    # Unset the variable in the current environment
    unset "$var_name"
    log_debug "Unset $var_name" 2>/dev/null

    # Remove the variable from the environment file
    if grep -q "^export $var_name=" "$env_file"; then
        sed -i '' "/^export $var_name=/d" "$env_file"
        log_debug "Removed $var_name from $env_file"
    fi
}

load_env_file() {
    env_file=${1:-$ENV_FILE}
    if [ -f "$env_file" ]; then
        if [ ! -r "$env_file" ]; then
            log_fatal "Environment file is not readable."
            return 1
        fi
    else
        log_fatal "Environment file does not exist."
        return 1
    fi

    source "$env_file"
}

check_all_vars_set_in_env_file() {
    local var_names=("$@")

    if [ -z "$var_names" ]; then
        log_fatal "Usage: check_all_vars_set_in_env_file <variable_name1> <variable_name2> ..."
        return 1
    fi

    for var_name in "${var_names[@]}"; do
        local valid_var_name=$(valid_bash_var_name "$var_name")

        if ! grep -q "^export $valid_var_name=" "$ENV_FILE"; then
            log_error "Variable $var_name is not declared in the .env file."
            return 1
        fi

        if ! grep -q "^export $valid_var_name=.*" "$ENV_FILE"; then
            log_error "Variable $var_name does not have a value in the .env file."
            return 1
        fi

        if [ -z "$(grep "^export $valid_var_name=.*" "$ENV_FILE" | cut -d'=' -f2-)" ]; then
            log_error "Variable $var_name has empty value in the .env file."
            return 1
        fi
    done
}

check_all_ip_vars_set_in_env_file_and_reachable() {
    local var_names=("$@")

    if [ -z "$var_names" ]; then
        log_fatal "Usage: check_all_ip_vars_set_in_env_file_and_reachable <variable_name1> [<variable_name2> ...]"
        return 1
    fi

    for var_name in "${var_names[@]}"; do
        local valid_var_name=$(valid_bash_var_name "$var_name")

        if ! grep -q "^export $valid_var_name=" "$ENV_FILE"; then
            log_error "Variable $var_name is not declared in the .env file."
            return 1
        fi

        if ! grep -q "^export $valid_var_name=.*" "$ENV_FILE"; then
            log_error "Variable $var_name does not have a value in the .env file."
            return 1
        fi

        local ip_address=$(grep "^export $valid_var_name=.*" "$ENV_FILE" | cut -d'=' -f2-)
        if [ -z "$ip_address" ]; then
            log_error "Variable $var_name has empty value in the .env file."
            return 1
        fi

        if ! ping -c 1 -W 1 "$ip_address" >/dev/null 2>&1; then
            log_error "IP address $ip_address for $var_name is not reachable."
            return 1
        fi
    done
}

check_var_set_in_env_file() {
    local var_name="$1"

    if [ -z "$var_name" ]; then
        log_fatal "Usage: check_var_set_in_env_file <variable_name>"
        return 1
    fi

    local valid_var_name=$(valid_bash_var_name "$var_name")

    if ! grep -q "^export $valid_var_name=" "$ENV_FILE"; then
        log_error "Variable $var_name is not declared in the .env file."
        return 1
    fi

    if ! grep -q "^export $valid_var_name=.*" "$ENV_FILE"; then
        log_error "Variable $var_name does not have a value in the .env file."
        return 1
    fi

    if [ -z "$(grep "^export $valid_var_name=.*" "$ENV_FILE" | cut -d'=' -f2-)" ]; then
        log_error "Variable $var_name has empty value in the .env file."
        return 1
    fi
}

update_bashrc() {
    local instantiated_template="$RUN_WORKSPACE/xb-bashrc-section.sh"
    cp "$XB_HOME/bashrc-section-template.sh" "$instantiated_template"
    sed -i '' "s|ENV_FILE|$ENV_FILE|g" "$instantiated_template"
    sed -i '' "s|XB_HOME|$XB_HOME|g" "$instantiated_template"
    sed -i '' "s|MG_WORKDIR|$MG_WORKDIR|g" "$instantiated_template"
    sed -i '' "s|XB_USER|$XB_USER|g" "$instantiated_template"
    sed -i '' "s|XB_USER_HOME|$XB_USER_HOME|g" "$instantiated_template"
    #the order of following line 3 lines is important
    sed -i '' "s|MACHINEFABRIC_HOME|$MACHINEFABRIC_HOME|g" "$instantiated_template"
    sed -i '' "s|ABRCITY_HOME|$ABRCITY_HOME|g" "$instantiated_template"
    sed -i '' "s|INFRA_DIR|$INFRA_DIR|g" "$instantiated_template"

    update_file_section "$instantiated_template" "$XB_USER_HOME/.bashrc" "$MG_BASHRC_SECTION_START" "$MG_BASHRC_SECTION_END" "$MG_BASHRC_SECTION_COMMENT"
}

xb_version() {
    local xb_version_file="$XB_HOME/version.txt"

    if [ ! -f "$xb_version_file" ]; then
        log_fatal "Version file not found."
    fi

    local result=$(cat "$xb_version_file")

    if [ -z "$result" ]; then
        log_fatal "Version file is empty."
        return 1
    fi

    echo "$result"
}

source_scripts() {
    # Convert the space-separated string into an array
    IFS=' ' read -r -a scripts_to_source <<<"$@"

    for script_path in "${scripts_to_source[@]}"; do
        source_script "$script_path"
        # prefix_source "$XB_HOME" "$script_path"
    done
}

list_directory_contents() {
    local dir_path="$1"

    # Check if the directory exists
    if [[ ! -d "$dir_path" ]]; then
        log_fatal "Directory does not exist."
        return 1
    fi

    # Initialize an empty array to store the paths
    local paths=()

    # Populate the array with absolute paths
    local item
    for item in "$dir_path"/*; do
        if [[ -e "$item" ]]; then # Check if the item exists
            # macOS compatible realpath alternative
            local abs_path
            abs_path="$(cd "$(dirname "$item")" && pwd)/$(basename "$item")"
            # Append to the paths array
            paths+=("$abs_path")
        fi
    done

    # Echo the paths as a space-separated list
    echo "${paths[*]}"
}

to_uppercase() {
    local input_string="$1"
    echo "$input_string" | tr '[:lower:]' '[:upper:]'
}

print_xb_header() {
    # ANSI color codes for styling
    NC='\033[0m' # No Color
    GREEN='\033[0;32m'
    BLUE='\033[0;34m'
    YELLOW='\033[1;33m'
    CYAN='\033[0;36m'
    MAGENTA='\033[0;35m'

    echo -e "${YELLOW}"
    print_title "$(to_uppercase "$PROJECT_NAME") | boxmux"
    echo -e "${MAGENTA}xbash v$(xb_version)${NC}"

    echo -e "${YELLOW}State file: ${MAGENTA}$RUN_STATE_FILE${NC}"
    echo -e "${YELLOW}Log file: ${MAGENTA}$RUN_LOG_FILE${NC}"
}

initialize_xb() {
    source_script() {
        local script_path="$1"
        if [ ! -f "$script_path" ]; then
            echo -e "$(date +'%Y-%m-%d %H:%M:%S') [ERROR] Script not found: $script_path"
            return 1
        fi
        source "$script_path"
    }

    if [ -z "$XB_HOME" ]; then
        XB_HOME="/Users/bahram/ws/prj/machinegenesis/boxmux" #"$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

        echo "CROSSBASH home is at:"
        read -p "[$XB_HOME]: " input
        XB_HOME=${input:-$XB_HOME}
        set_env_var "XB_HOME" "$XB_HOME" "$MASTER_ENV_FILE"
    fi
    LIB_DIR="$XB_HOME/lib"

    if [ -z "$PROJ_HOME_DIR" ]; then
        PROJ_HOME_DIR="/Users/bahram/ws/prj/machinegenesis"
        echo "Project home is at:"
        read -p "[$PROJ_HOME_DIR]: " input
        PROJ_HOME_DIR=${input:-$PROJ_HOME_DIR}
        set_env_var "PROJ_HOME_DIR" "$PROJ_HOME_DIR" "$MASTER_ENV_FILE"
    fi

    ENV_FILE="$PROJ_HOME_DIR/.xbash_profile"

    if [ ! -f "$ENV_FILE" ]; then
        cp "$XB_HOME/xbash_profile-template" "$ENV_FILE" || { echo "Failed to create $ENV_FILE" && exit 1; }
        sudo chmod +x "$ENV_FILE"
    fi

    source_script "$ENV_FILE" || { echo "Failed to source $ENV_FILE" && exit 1; }

    # ABRCITY_HOME="$XB_HOME/abrcity"
    # MACHINEFABRIC_HOME="$XB_HOME/machinefabric"
    # INFRA_DIR="$XB_HOME/infra"

    if [ -z "$LOG_LEVEL" ]; then
        LOG_LEVEL=3
        set_env_var "LOG_LEVEL" "$LOG_LEVEL"
    fi

    source_script "$XB_HOME/lib/log_lib.sh" || { echo "Failed to source log_lib.sh" >&2 && exit 1; }

    if [ -z "$PROJECT_NAME" ]; then
        PROJECT_NAME=$(basename "$PROJ_HOME_DIR")
        echo "Project name is:"
        read -p "[$PROJECT_NAME]: " input
        PROJECT_NAME=${input:-$PROJECT_NAME}
        set_env_var "PROJECT_NAME" "$PROJECT_NAME"
    fi

    # if [ -z "$SUB_PROJECTS" ]; then
    # if [ ${#defined_sub_projects[@]} -eq 0 ]; then
    # echo "The xbash profile at your project home directory does not define any sub projects."
    #     # echo "Please enter the sub projects paths separated by space:"
    #     # read -p "[$entered_subprojects]: " input
    #     # entered_subprojects=${input:-$entered_subprojects}
    #     # set_env_var "SUB_PROJECTS" "$entered_subprojects"
    # else
    #     echo "The xbash profile at your project home directory defines the following sub projects:"
    #     echo "$defined_sub_projects"
    #     # echo "Do you want to add more sub projects?"
    #     # read -p "[y/n]: " input
    #     # if [ "$input" == "y" ]; then
    #     #     echo "Please enter the sub projects paths separated by space:"
    #     #     read -p "[$defined_sub_projects]: " input
    #     #     entered_subprojects=${input:-$defined_sub_projects}
    #     #     set_env_var "SUB_PROJECTS" "$entered_subprojects"
    #     # fi
    # fi
    # fi

    if [ -z "$PROJECT_WORKDIR" ]; then
        PROJECT_WORKDIR="$USER_XB_DIR/$PROJECT_NAME"

        echo "Please enter the working directory for your project:"
        read -p "[$PROJECT_WORKDIR]: " input
        PROJECT_WORKDIR=${input:-$PROJECT_WORKDIR}
        mkdir -p "$PROJECT_WORKDIR"
        set_env_var "PROJECT_WORKDIR" "$PROJECT_WORKDIR"

        set_env_var "CACHE_DIR" "$XB_USER_HOME/.boxmux/cache"

    fi

    if [ -z "$HOST_LAN_ADAPTER" ]; then
        HOST_LAN_ADAPTER="eno2"

        echo "Please enter the host LAN adapter:"
        read -p "[$HOST_LAN_ADAPTER]: " input
        HOST_LAN_ADAPTER=${input:-$HOST_LAN_ADAPTER}
        set_env_var "HOST_LAN_ADAPTER" "$HOST_LAN_ADAPTER" "$MASTER_ENV_FILE"
    fi

    if [ -z "$HOST_WLAN_ADAPTER" ]; then
        HOST_WLAN_ADAPTER="wlo1"

        echo "Please enter the host WLAN adapter:"
        read -p "[$HOST_WLAN_ADAPTER]: " input
        HOST_WLAN_ADAPTER=${input:-$HOST_WLAN_ADAPTER}
        set_env_var "HOST_WLAN_ADAPTER" "$HOST_WLAN_ADAPTER" "$MASTER_ENV_FILE"
    fi

    scripts_to_source=$(list_directory_contents "$LIB_DIR")

    source_scripts "${scripts_to_source[@]}"

    # add_wait_marquee

    print_xb_header
    ensure_env_file_exists "$ENV_FILE"
    update_bashrc
    install_dependency_repos
    install_dependencies
    manual_setup
    download_duckdb
    initialize_db
    initialize_layouts

    write_to_run_state "timestamp" "$(date +'%Y-%m-%d %H:%M:%S')"
    write_to_run_state "xb_version" "$(xb_version)"
    write_to_run_state "running_user" "$(whoami)"
    # remove_wait_marquee
}

purge() {
    local hard=${1:-false}
    if [ -n "$USER_XB_DIR" ]; then
        if [ "$hard" == "true" ]; then
            echo "PERFORMING A HARD PURGE"
            echo "Purging dir $USER_XB_DIR, including the master.env file."
            rm -rf "$USER_XB_DIR"
        else
            #delete everything from USER_XB_DIR except master_env file
            echo "PERFORMING A SOFT PURGE"
            echo "Purging dir $USER_XB_DIR, except the master.env file."
            find "$USER_XB_DIR" -mindepth 1 -maxdepth 1 -not -name "master.env" -exec rm -rf {} \;
        fi
    else
        log_error "User xbash directory is not set."
    fi

    if [ -n "$PROJ_HOME_DIR" ]; then
        echo "Removing xbash profile from project home directory, $PROJ_HOME_DIR."
        rm -f "$PROJ_HOME_DIR/.xbash_profile"
    else
        echo "Project home directory is not set."
    fi
    rm -f "$ENV_FILE"
}

check_for_immediate_commands() {
    if [ -z "$1" ]; then
        return 0
    fi

    args=("$@")

    case "$1" in
    "purge")
        purge "${args[1]}"
        exit 0
        ;;
    *)
        log_error "Invalid command: $1"
        ;;
    esac
}

# Prevent the file from being sourced multiple times
if [ -z "$ROOT_BASH_SOURCED" ]; then
    ROOT_BASH_SOURCED=1

    XB_USER=$(whoami)
    XB_USER_HOME=$(eval echo ~"$XB_USER")
    XB_USERGROUP=$(id -gn "$XB_USER")
    USER_XB_DIR="$XB_USER_HOME/.boxmux"
    MASTER_ENV_FILE="$USER_XB_DIR/master.env"
    mkdir -p "$USER_XB_DIR"
    touch "$MASTER_ENV_FILE"
    source "$MASTER_ENV_FILE"

    check_for_immediate_commands "$@"

    initialize_xb
fi

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    if [ -z "$1" ]; then
        # No function name supplied, do nothing
        exit 0
    fi

    func_name="$1" # Store the first argument (function name)
    shift          # Remove the first argument, now $@ contains only the arguments for the function

    # Check if the function exists
    if declare -f "$func_name" >/dev/null; then
        "$func_name" "$@" # Call the function with the remaining arguments
    else
        log_fatal "'$func_name' is not a valid function name."
        exit 1
    fi
fi
